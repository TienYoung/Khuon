#version 460
 
#extension GL_NV_mesh_shader : require
 
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = 64, max_primitives = 126) out;
 
//-------------------------------------
// transform_ub: Uniform buffer for transformations
//
layout (std140, binding = 0) uniform uniforms_t
{ 
  mat4 ViewProjectionMatrix;
  mat4 ModelMatrix;
} transform_ub;
 
//-------------------------------------
// vb: storage buffer for vertices.
//
struct s_vertex
{
  vec3 position;
  vec3 normal;
  vec2 texcoord;
};
 
layout (std430, binding = 1) buffer _vertices
{
  s_vertex vertices[];
} vb;
 
//-------------------------------------
// mbuf: storage buffer for meshlets.
//
struct s_meshlet
{
  uint vertices[64];
  uint indices[378]; // up to 126 triangles
  uint vertex_count;
  uint index_count;
};
 
layout (std430, binding = 2) buffer _meshlets
{
  s_meshlet meshlets[];
} mbuf;
 
// Mesh shader output block.
//
layout (location = 0) out PerVertexData
{
  vec4 color;
} v_out[];   // [max_vertices]
 
// Color table for drawing each meshlet with a different color.
//
#define MAX_COLORS 10
vec3 meshletcolors[MAX_COLORS] = {
  vec3(1,0,0), 
  vec3(0,1,0),
  vec3(0,0,1),
  vec3(1,1,0),
  vec3(1,0,1),
  vec3(0,1,1),
  vec3(1,0.5,0),
  vec3(0.5,1,0),
  vec3(0,0.5,1),
  vec3(1,1,1)
  };
 
void main()
{
  uint mi = gl_WorkGroupID.x;
  uint thread_id = gl_LocalInvocationID.x;
 
  uint vertex_count = mbuf.meshlets[mi].vertex_count;
  for (uint i = 0; i < vertex_count; ++i)
  {
    uint vi = mbuf.meshlets[mi].vertices[i];
 
    gl_MeshVerticesNV[i].gl_Position = transform_ub.ViewProjectionMatrix * transform_ub.ModelMatrix * vec4(vb.vertices[vi].position, 1.0);
 
    v_out[i].color = vec4(meshletcolors[mi%MAX_COLORS], 1.0);
  }
 
  uint index_count = mbuf.meshlets[mi].index_count;
  gl_PrimitiveCountNV = uint(index_count) / 3;
 
  for (uint i = 0; i < index_count; ++i)
  {
    gl_PrimitiveIndicesNV[i] = uint(mbuf.meshlets[mi].indices[i]);
  }
}